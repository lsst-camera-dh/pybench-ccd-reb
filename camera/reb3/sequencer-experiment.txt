# REB3 timing for E2V CCD, in new REB sequencer format
# more experimental sequences
# (C. Juramy, 20160201)
# modified 20160321 with include functionality, CCS-compatible keywords

[includes]  # inheritance from other files (in increasing priority order, current file last)
    camera/reb3/sequencer-reb3.txt

[constants]  # will be substituted in the code at compilation time

[clocks]  # clock channels

[pointers]  # can define a pointer to a function or to a repetition number (for subroutines or functions)
    PTR_FUNC    ReadoutPixel    ReadPixel  # Points to the readout function we want to use

[functions]
    ReadRD:  # Simulated pixel signal with RG
      clocks:          RG, S1, S2, S3, CL, RST, RD, RU, TRG
      slices:
         TimeS       = 1,  0,  1,  0,  1,  1,  0,  0,  0
         BufferS     = 1,  0,  1,  1,  1,  1,  0,  0,  0
         BufferS     = 1,  0,  1,  1,  1,  1,  0,  0,  0
         BufferS     = 1,  0,  0,  1,  0,  0,  0,  0,  0
         RampBuffer  = 1,  0,  0,  1,  0,  0,  1,  0,  0
         BufferS     = 1,  1,  0,  1,  0,  0,  1,  0,  0
         ISO2        = 0,  1,  0,  0,  0,  0,  0,  0,  0
         RampTime    = 0,  1,  0,  0,  0,  0,  0,  1,  0
         BufferS     = 0,  1,  1,  0,  0,  0,  0,  0,  0
         50 ns       = 0,  0,  1,  0,  0,  0,  0,  0,  1
      constants:     P2=1, P3=1

    ReadNoReset:  # Transfer pixel content without resetting and reads
      clocks:          RG, S1, S2, S3, CL, RST, RD, RU, TRG
      slices:
         TimeS       = 0,  0,  1,  0,  0,  0,  0,  0,  0
         BufferS     = 0,  0,  1,  1,  0,  0,  0,  0,  0
         BufferS     = 0,  0,  1,  1,  0,  0,  0,  0,  0
         BufferS     = 0,  0,  0,  1,  0,  0,  0,  0,  0
         RampBuffer  = 0,  0,  0,  1,  0,  0,  1,  0,  0
         BufferS     = 0,  1,  0,  1,  0,  0,  1,  0,  0
         ISO2        = 0,  1,  0,  0,  0,  0,  0,  0,  0
         RampTime    = 0,  1,  0,  0,  0,  0,  0,  1,  0
         BufferS     = 0,  1,  1,  0,  0,  0,  0,  0,  0
         50 ns       = 0,  0,  1,  0,  0,  0,  0,  0,  1
      constants:     P2=1, P3=1

    ReadReverse:  # Clocks in reverse direction and reads as usual
      clocks:          RG, S1, S2, S3, CL, RST, RD, RU, TRG
      slices:
         TimeS       = 1,  0,  1,  0,  1,  1,  0,  0,  0
         BufferS     = 1,  1,  1,  0,  1,  1,  0,  0,  0
         BufferS     = 0,  1,  1,  0,  1,  1,  0,  0,  0
         BufferS     = 0,  1,  0,  0,  0,  0,  0,  0,  0
         RampBuffer  = 0,  1,  0,  0,  0,  0,  1,  0,  0
         BufferS     = 0,  1,  0,  1,  0,  0,  1,  0,  0
         ISO2        = 0,  0,  0,  1,  0,  0,  0,  0,  0
         RampTime    = 0,  0,  0,  1,  0,  0,  0,  1,  0
         BufferS     = 0,  0,  1,  1,  0,  0,  0,  0,  0
         50 ns       = 0,  0,  1,  0,  0,  0,  0,  0,  1
      constants:     P2=1, P3=1

[subroutines]
    WindowLine:  # Line readout with option for read function (overwrites parent file)
        CALL    SerialFlush       repeat(@PreCols)
        CALL    @ReadoutPixel     repeat(@ReadCols)
        CALL    SerialFlush       repeat(@PostCols)
        RTS

    WarmUp:  # Warms up analog electronics and ADCs
        CALL    @ReadoutPixel       repeat(256)  # any other value will mess up the scanning mode
        RTS

    SerialReverseBlock:  # creates artificial stripes of light and empty pixels
        CALL    ReadPixel         repeat(20)
        CALL    ReadReverse       repeat(10)

    SerialReverseLine:
        CALL    SerialFlush         repeat(@PreCols)
        JSR     SerialReverseBlock  repeat(8)
        CALL    ReadPixel           repeat(16)
        CALL    SerialFlush         repeat(160)
        CALL    SerialFlush         repeat(@PostCols)
        RTS

    MemoryFrame:
        JSR     WarmUp
        JSR     FlushLine         repeat(@PreRows)
        CALL    StartOfImage
        JSR     SerialReverseLine repeat(@ReadRows)
        CALL    EndOfImage
        JSR     FlushLine         repeat(@PostRows)
        RTS

[mains]
    Memory:
        JSR     AcquireFrame
        JSR     MemoryFrame
        END

