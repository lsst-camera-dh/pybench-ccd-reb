#! /usr/bin/env python

# --------------------------------------------------------------------------
# SnDICE2 server
# To test the communication with the CFHT TCS / MegaCam DAQ system
# --------------------------------------------------------------------------

import sys
import os, os.path
import time
import subprocess
import sys, os 
import signal
import shutil
import socket # to get the hostname
import datetime

# --------------------------------------------------------------------------
import logging
#logging.basicConfig(level=logging.DEBUG,format='%(asctime)s: %(message)s')
# --------------------------------------------------------------------------

import xmlrpclib
from SimpleXMLRPCServer import SimpleXMLRPCServer

from exceptions import Exception

class MotorError(Exception): pass
class BackendError(Exception): pass
class CommandError(Exception): pass


# --------------------------------------------------------------------------
DEFAULT_HOSTNAME = "localhost"
DEFAULT_PORT     = 8000
SERVER_HOSTNAME = os.getenv("DICE_SERVER_HOSTNAME", DEFAULT_HOSTNAME)
SERVER_PORT = int(os.getenv("DICE_SERVER_PORT", DEFAULT_PORT))

# --------------------------------------------------------------------------

class DiceServer(SimpleXMLRPCServer):
    def serve_forever(self):
	self.quit = 0
	while not self.quit:
	    self.handle_request()

# --------------------------------------------------------------------------
import dice.control.motor as dcm         # mcapi.py 
# import dice.control.led as dcl           # led specs # ici, ca ne sert pas. 
import dice.control.led as specs    
# import dice.control.utils as dcu         # Q: just bytes.py ?


def dice_led_on_off(led, current, on):
    """
    From the testbench scripts. 
    Call the dice-led-on-off command from a subprocess. 
    (Safer because the LAL USB code may segfault sometimes).
    """
    on_str = "OFF"
    if on:
        on_str = "ON"
        
    command = ( "dice-led-on-off --current %f  %d  %s" % 
                (current, led, on_str) )
    logging.info(command)
    #    remote_command = "ssh %s %s" % (dicehead_host, command)
    proc = subprocess.Popen(command, shell=True,
                            stdout = subprocess.PIPE,
                            stderr = subprocess.PIPE)
    (out, err) = proc.communicate()
    logging.info(out)
    logging.info(err)
    #    if err!=0:
    #        raise BackendError("%s : return %d" % (command, err))
    return True

def dice_sample(channel):
    """
    From the testbench scripts. 
    Call the dice-led-on-off command from a subprocess. 
    (Safer because the LAL USB code may segfault sometimes).
    """
    command = ("dice-sample %d" % channel)
    #    remote_command = "ssh %s %s" % (dicehead_host, command)
    proc = subprocess.Popen(command, shell=True,
                            stdout = subprocess.PIPE,
                            stderr = subprocess.PIPE)
    (out, err) = proc.communicate()
    parts = out.strip().split()
    #    print parts
    if len(parts) !=5 :
        raise BackendError("Failed to run dice-sample on %s" % dicehead_host)
    #
    # 1332329172.153316     63    4681    -26.865627    4047.965067
    t = float(parts[0])
    c = int(parts[1])
    n = int(parts[2])
    mean = float(parts[3])
    variance = float(parts[4])
    #
    return t, c, n, mean, variance


# --------------------------------------------------------------------------
class LEDHead(object):
    
    # status codes 
    AXIS_IDLE = 0          # not initialized yet 
    AXIS_INITIALIZED = 1   # initialized 
    AXIS_READY = 2         # homed, and ready to move
    AXIS_MOVING = 3        # moving 
        
    BACKEND_IDLE = 0
    BACKEND_READY = 1
    BACKEND_LED_ON = 2
    BACKEND_LED_OFF = 3
    
    instance = None

    def __new__(cls, *args, **kargs):
        if cls.instance is None: 
            cls.instance = object.__new__(cls, *args, **kargs)
        return cls.instance
    
    def __init__(self):
        self.state = {
            "alt_motor": LEDHead.AXIS_IDLE, 
            "az_motor": LEDHead.AXIS_IDLE, 
            "backend": LEDHead.BACKEND_IDLE
            }
        self.motor_controller = None
        self.alt_axis = None
        self.az_axis = None
        
        # self.control_values = {} # not sure I need to hook that to the LedHead object 
        

    # ------------- LEDHEAD General Control ------------------------------------
    def status(self):
        """
        Return the status of the system.
        """
        return self.state 
    #        return { "backend"   : Status.BACKEND_READY, 
    #                 "alt_motor" : Status.ALT_READY,
    #                 "az_motor"  : Status.AZ_READY }

    def init(self):
        """
        Init the DICE2 subsystems:
        - init the motors 
        - init the backend
        """
        logging.info("LEDHead.init() called.")
        self.motor_init()
        #  self.backend_init()
        logging.info("LEDHead.init() done.")
        return True
    
    # ----------------------- LEDHEAD Motion -----------------------
    def home(self):
        """
        Home the motors, i.e. move up, down, left, right to test the
        mechanical motor stops and reset the motor zeros.  Should be
        called once at the begining of a run.
        
        WARNING: blocking call. Takes about 20s.
        
        see: ledhead.LEDHead.home()/ledhead.LEDHead.motor_home()
        mcapi.Axis.home()/mcapi.Axis.find_limits()
        """
        logging.info("LEDHead.home() called.")
        logging.info("LEDHead.home() Homing the ALT axis...")
        self.alt_axis.home()
        logging.info("LEDHead.home() Homing the ALT axis done.")
        logging.info("LEDHead.home() Homing the AZ axis...")
        self.az_axis.home()
        logging.info("LEDHead.home() Homing the AZ axis done.")
        logging.info("LEDHead.home() done.")
        return True
    
    def move_absolute(self, alt, az, wait=False, check=True):
        """
        Move the LED head to the specified absolute position ('alt', 'az'), 
        expressed in coder steps.
        
        - if wait==True, the call is blocking,
        - otherwise, the call returns immediately, and one has to poll
        the motor status (with the status() call) to check whether the
        head is still moving or not.
        
        see: ledhead.LEDHead.move_absolute()
        mcapi.Axis.move_absolute()
        """
        logging.info("LEDHead.move_absolute(%d, %d) called." % (alt, az))
        logging.info("LEDHead.move_absolute() moving to absolute position (%d,%d)" % (alt, az))
        self.alt_axis.move_absolute(alt, wait=wait, check=check)
        self.az_axis.move_absolute(az, wait=wait, check=check)
        logging.info("LEDHead.move_absolute(%d, %d) done." % (alt, az))
        return True
        
    def move_relative(self, dalt, daz, wait=False, check=True):
        """
        move the LED head by 'dalt' steps in altitude and 'daz' coder
        steps in azimuth. 
        
        - if wait==True, the call is blocking,
        - otherwise, the call returns immediately, and one has to poll
        the motor status (with the (status() call) to check whether the
        head is still moving or not.
        
        see: ledhead.LEDHead.move_relative()
        mcapi.Axis.move_absolute()
        """
        logging.info("LEDHead.move_relative(%d, %d) called." % (dalt, daz))
        logging.info("LEDHead.move_relative() moving of relative offset (%d,%d)" % (dalt, daz))
        self.alt_axis.move_relative(dalt, wait=wait, check=check)
        self.az_axis.move_relative(daz, wait=wait, check=check)
        logging.info("LEDHead.move_relative(%d, %d) done." % (dalt, daz))
        return True
            
    def at_target(self):
        """
        return True if both motors have reached their assigned position. 
        return False otherwise. 
        
        see: mcapi.Axis.at_target
        """
        logging.info("at_target called.")
        alt = self.alt_axis.at_target()
        az = self.az_axis.at_target()
        logging.info("at_target done.")
        return alt and az

    def position(self):
        """
        Return the position of both axes. 
        see: LEDHead.motor_position
        """
        logging.info("LEDHead.position() called.")
        res = (self.alt_axis.position, self.az_axis.position)
        logging.info("LEDHead.position() done.")
        return res

    def park(self, wait=False, check=True):
        """
        Move the head to a predefined parking position.
        
        - if wait==True, the call is blocking,
        - otherwise, the call returns immediately, and one has to poll
        the motor status (with the (status() call) to check whether the
        head is still moving or not.
        """
        # TODO: define a safe parking position 
        alt_park = 0
        az_park = 0
        
        logging.info("LEDHead.park() called.")
        self.move_absolute(alt_park, az_park, wait=wait, check=check)
        logging.info("LEDHead.park() done.")
        return True

    def motor_status():
        """
        Return the status of both motors. 
        
        ajouter is_on();
        see: mcapi.LEDHead.
        """
        logging.info("motor_status() called.")
        time.sleep(1.)
        logging.info("motor_status() done.")
        return (Status.ALT_READY, Status.AZ_READY)
        
    def motor_init(self):
        logging.info("LEDHead.motor_init() called.")
        if self.motor_controller == None:
            self.motor_controller = dcm.Controller()
            self.motor_controller.open()
            self.motor_controller.setup()
            
        if self.motor_controller.axes.has_key(3):
            self.az_axis = self.motor_controller.axes[3]
        if self.motor_controller.axes.has_key(4):
            self.alt_axis = self.motor_controller.axes[4]
            
        logging.info("LEDHead.motor_init() done.")
        return True
        
    # ----------------------- LED Control --------------------------
    def led_on(self, led, current=None):
        logging.info("LEDHead.led_on() called.")
        if led<1 or led>24 or led==4:
            raise CommandError("LEDHead.led_on(): invalid LED number (%d)." % led)
        if current is None:
            current = specs.LEDS[led]['dac']
        if current >= specs.LEDS[led]['max_dac']:
            raise CommandError("LEDHead.led_on(): LED current above limit: %d > %d" % (current, specs.LEDS[led]['max_dac']))
        logging.info("LEDHead.led_on() Turn ON LED %d with current=%d" % (led, current))
        dice_led_on_off(led, current, True)
        logging.info("LEDHead.led_on() done.")
        return True
        
    def led_off(self):
        logging.info("led_off() called.")
        logging.info("led_off() Turn OFF LED.")
        dice_led_on_off(1, 0, False) # in fact, this turns off all the LEDs
        logging.info("led_off() done.")
        return True
        
    def planet_on(self, current=None):
        logging.info("planet_on() called.")
        logging.info("planet_on() Turn ON PLANET.")
        if current is None:
            current = specs.LEDS[4]['dac']
        if current >= specs.LEDS[4]['max_dac']:
            raise CommandError("LEDHead.planet_on(): LED current above limit: %d > %d" % (current, specs.LEDS[4]['max_dac']))
        dice_led_on_off(4, current, True)
        logging.info("planet_on() done.")
        return True
    
    def planet_off(self):
        logging.info("LEDHead.planet_off() called.")
        logging.info("LEDHead.planet_off() Turn OFF PLANET.")
        dice_led_on_off(4, 0, False) # in fact, this turns off all the LEDs
        logging.info("LEDHead.planet_off() done.")
        return True
    
    def sample_and_dump(self, led):
        logging.info("LEDHead.sample_and_dump() called.")
        result = []
        channel = {
            'ILED': led, 
            'IPHD': led+33, 
            'T24':  58, 
            'TBE':  59, 
            'VREF': 61 }        
        for p in ["ILED", "IPHD", "T24", "TBE", "VREF"]:
            logging.info("LEDHead.sample_and_dump() sampling channel: %d (%s)" % (channel[p], p))
            t, c, n, mean, variance = dice_sample(channel[p])
            result.append([p + 'T', t])
            result.append([p + 'C', c])
            result.append([p + 'N', n])
            result.append([p + 'M', mean])
            result.append([p + 'V', variance])
            logging.info("LEDHead.sample_and_dump() sampling channel: %d (%s) done." % (channel[p], p))
        logging.info("LEDHead.sample_and_dump(%d) returns:" % led + str(result))
        logging.info("LEDHead.sample_and_dump(%d) done." % led)
        return result
    
    def backend_reset():
        """Reset the LED backend"""
        logging.info("backend reset called.")
        time.sleep(5)
        logging.info("backend reset done.")
        return True
    
# ------------- Missing functions and tests --------------------------------
def server_quit():
    logging.info("Server going down.")
    server.quit = 1
    return 1


# ------------- Deamonization ---------------------
# Default working directory for the daemon.
WORKDIR = "/"

def redirect_stream(system_stream, target_stream):
    """ Redirect a system stream to a specified file.
    
    `system_stream` is a standard system stream such as
    ``sys.stdout``. `target_stream` is an open file object that
    should replace the corresponding system stream object.

    If `target_stream` is ``None``, defaults to opening the
    operating system's null device and using its file descriptor.
    
    """
    if target_stream is None:
        target_fd = os.open(os.devnull, os.O_RDWR)
    else:
        target_fd = target_stream.fileno()
    os.dup2(target_fd, system_stream.fileno())


def daemonize(options, args):
    try: 
        pid = os.fork() 
        if pid > 0:
            # exit first parent
            sys.exit(0) 
    except OSError, e: 
        print >>sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror) 
        sys.exit(1)

        
    # Become leader of a new session to decouple from the controlling tty
    os.setsid() 
    # We stay with the same umask
    # os.umask(0) 

    # do second fork and kill session leader to ensure one will never get attach to a TTY.
    try: 
        pid = os.fork() 
        if pid > 0:
            # exit from second parent, print eventual PID before
            print "Starting server as daemon with PID %d ..." % pid 
            sys.exit(0) 
    except OSError, e: 
        print >>sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror) 
        sys.exit(1) 
    

    # start the daemon main
    main(options, args) 


def main(options, args):

    logging.basicConfig(filename=options.log_file, 
                        level=logging.DEBUG, format='%(asctime)s: %(message)s')

    # Now that logging is set up decouple from parent environnement
    redirect_stream(sys.stdin, None)
    redirect_stream(sys.stdout, None)
    redirect_stream(sys.stderr, None)    

    # General Control Functions 
    server.register_function(SnDICE2.status,              "status")
    server.register_function(SnDICE2.init,                "init")

    # LEDHEAD motions 
    server.register_function(SnDICE2.home,                "home")
    server.register_function(SnDICE2.move_absolute,       "move_absolute")
    server.register_function(SnDICE2.move_relative,       "move_relative")
    server.register_function(SnDICE2.at_target,           "at_target")
    server.register_function(SnDICE2.position,            "position")
    server.register_function(SnDICE2.park,                "park")
    server.register_function(SnDICE2.motor_status,        "motor_status")
    server.register_function(SnDICE2.motor_init,          "motor_init")
    
    # LEDHEAD motions 
    server.register_function(SnDICE2.led_on,              "led_on")
    server.register_function(SnDICE2.led_off,             "led_off")
    server.register_function(SnDICE2.planet_on,           "planet_on")
    server.register_function(SnDICE2.planet_off,          "planet_off")
    server.register_function(SnDICE2.sample_and_dump,     "sample_and_dump")

    # misc 
    server.register_function(server_quit,         "quit")
    logging.info("Server going up.")
    server.serve_forever()
    # -----------------------------------------------------------------------



if __name__ == '__main__':
    now = datetime.datetime.now()
    logname = "dice-server-%s.log" % now.isoformat().split('T')[0]

    import optparse
    parser = optparse.OptionParser(usage="""
%prog [-l log-file] [-d] 

Start the dice2 control server. 
""")
    parser.add_option('-d', '--daemon', default=False, action='store_true',
                      help='Run as a background daemon')
    parser.add_option('-p', '--port', default=SERVER_PORT, action='store', type='int',
                      help='Listen on port')
    parser.add_option('-H', '--hostname', default=SERVER_HOSTNAME, action='store',
                      help='Listen adress')
    parser.add_option('-l', '--log-file', default=logname, action='store',
                      help='Specify a file for daemon logs.')

    (options, args) = parser.parse_args()

    # ------------- Initialize Head ---------------
    SnDICE2 = LEDHead()
    # ------------- LEDHEAD Server ----------------
    # HOSTNAME = DEFAULT_HOSTNAME
    # PORT = DEFAULT_PORT
    SERVER_HOSTNAME = options.hostname
    SERVER_PORT = options.port
    
    server = DiceServer((SERVER_HOSTNAME, SERVER_PORT))
    # server = SimpleXMLRPCServer(("dicehead", 8001))
    print "dice2: Listening on port %s:%d. Waiting for commands." % (SERVER_HOSTNAME, SERVER_PORT)
    
    if options.daemon:
        daemonize(options, args)
    else:
        main(options, args)
