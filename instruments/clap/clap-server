#! /usr/bin/env python
#
# ==================================================================
#
# LSST
#
# Remote control (XPL-RPC) of the CLAP for the LSST testbench
# XML-RPC server to control it remotely
# default device: /dev/--- on lpnlsstclap
# default port: 81
#
# Authors: Laurent Le Guillou 
# (recycled from DICE control system code)
#
# ==================================================================

import sys
import os, os.path
import time
import subprocess
import sys, os 
import signal
import shutil
import socket # to get the hostname
import datetime

# ==================================================================

import logging
# logging.basicConfig(level=logging.DEBUG,format='%(asctime)s: %(message)s')

# ==================================================================

import inspect
import xmlrpclib
from SimpleXMLRPCServer import SimpleXMLRPCServer, list_public_methods

# ==================================================================

from exceptions import Exception

# class MotorError(Exception): pass

# ==================================================================

# DEFAULT_HOSTNAME = "lpnlsstbench"
DEFAULT_HOSTNAME = "134.158.155.98"
DEFAULT_PORT     = 8211
DEFAULT_DEVICE   = "/dev/ttyS1"

SERVER_HOSTNAME = os.getenv("KEITHLEY_SERVER_HOSTNAME", DEFAULT_HOSTNAME)
SERVER_PORT     = int(os.getenv("KEITHLEY_SERVER_PORT", DEFAULT_PORT))
SERVER_DEVICE   = os.getenv("KEITHLEY_SERVER_DEVICE", DEFAULT_DEVICE)

# ==================================================================

class KeithleyServer(SimpleXMLRPCServer):
    def serve_forever(self):
	self.quit = 0
	while not self.quit:
	    self.handle_request()

    # def __getattr__(self, name):
    #     if name == '__doc__':
    #         return 'sub special'
    #     else:  
    #         raise AttributeError, name

# ==================================================================

import lsst.instruments.keithley as keithley

# ==================================================================

class KeithleyRemote(object):
    
    instance = None

    # --------------------------------------------------------------

    def __new__(cls, *args, **kargs):
        if cls.instance is None: 
            cls.instance = object.__new__(cls, *args, **kargs)
        return cls.instance
    
    def __init__(self,
                 device = '/dev/ttyS0',
                 debug = True):
        self.state = 1
        self.device = device
        self.keithley = keithley.Multimeter(device = device,
                                            debug = debug)

    # --------------------------------------------------------------

    def status(self):
        """
        Return the status of the system.
        """
        return self.state 

    # --------------------------------------------------------------

    def open(self):
        """
        Open the connection with the Keithley multimeter.
        """
        logging.info("Keithley.open() called.")
        self.keithley.open()
        logging.info("Keithley.open() done.")
        return True

    def close(self):
        """
        Close the connection with the Keithley multimeter.
        """ 
        logging.info("Keithley.close() called.")
        self.keithley.close()
        logging.info("Keithley.close() done.")
        return True

    def reset(self):
        """
        Reset the instrument to the factory default settings
        (with the exception of all remote interface settings).
        """
        logging.info("Keithley.reset() called.")
        self.keithley.reset()
        logging.info("Keithley.reset() done.")
        return True

    def clear(self):
        """
        Clear the instrument status.
        """ 
        logging.info("Keithley.clear() called.")
        self.keithley.clear()
        logging.info("Keithley.clear() done.")
        return True
    
    # ----------------------- Keithley generic command ------------------

    def send(self, command, timeout = None):
        """
        Send a command through the serial port.
        Read the answer from the serial port.
        Return it as a string.

        If <timeout> is specified, the function will wait
        for data with the specified timeout (instead of the default one). 
        """

        logging.info("Keithley.send() called.")
        logging.info("  command = [%s]" % command)
        answer = self.keithley.send(command, timeout = timeout)
        logging.info("  answer = [%s]" % answer)
        logging.info("Keithley.send() done.")
        return answer

    def get_error_status(self):
        """
        Get (and clear) the Standard Event Status Register.
        Return ESR value.
        """
        logging.info("Keithley.get_error_status() called.")
        esr = self.keithley.get_error_status()
        logging.info("  ESR = [%d]" % esr)
        logging.info("Keithley.get_error_status() done.")
        return esr

    # ----------------------- Keithley identification -------------------

    def get_serial(self):
        """
        Return the identification string of the Keithley.
        """
        logging.info("Keithley.get_serial() called.")
        serial = self.keithley.get_serial()
        logging.info("  serial = [%s]" % serial)
        logging.info("Keithley.get_serial() done.")
        return serial

    # ----------------------- Various methods ---------------------------

    def scroll_text(self, msg):
        """
        Scroll text 'msg' on the Multimeter display.
        For debug purpose only.
        """
        logging.info("Keithley.scroll_text() called.")
        self.keithley.scroll_text(msg)
        logging.info("Keithley.scroll_text() done.")
        return True

    # ----------------------- Introspection -----------------------------

    def _listMethods(self):
        logging.info("Keithley._listMethods() called.")
        methods = list_public_methods(self)
        logging.info("Keithley._listMethods() done.")
        return methods

    def _methodHelp(self, method):
        f = getattr(self, method)
        return inspect.getdoc(f)

# ==================================================================

# ------------- Missing functions and tests ------------------------

def server_quit():
    logging.info("Server going down.")
    server.quit = 1
    return 1

# ==================================================================

# ------------- Daemonization ---------------------------------------
# Default working directory for the daemon.
WORKDIR = "/"

def redirect_stream(system_stream, target_stream):
    """ 
    Redirect a system stream to a specified file.
    
    'system_stream' is a standard system stream such as
    ''sys.stdout''. 'target_stream' is an open file object that
    should replace the corresponding system stream object.

    If 'target_stream' is ''None'', defaults to opening the
    operating system's null device and using its file descriptor.
    
    """

    if target_stream is None:
        target_fd = os.open(os.devnull, os.O_RDWR)
    else:
        target_fd = target_stream.fileno()
    os.dup2(target_fd, system_stream.fileno())


def daemonize(options, args):
    try: 
        pid = os.fork() 
        if pid > 0:
            # exit first parent
            sys.exit(0) 
    except OSError, e: 
        print >>sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror) 
        sys.exit(1)

    # Become leader of a new session to decouple from the controlling tty
    os.setsid() 
    # We stay with the same umask
    # os.umask(0) 

    # do second fork and kill session leader to ensure one will never get attach to a TTY.
    try: 
        pid = os.fork() 
        if pid > 0:
            # exit from second parent, print eventual PID before
            print "Starting server as daemon with PID %d ..." % pid 
            sys.exit(0) 
    except OSError, e: 
        print >>sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror) 
        sys.exit(1) 
    

    # start the daemon main
    main(options, args) 


def main(options, args):

    logging.basicConfig(filename=options.log_file, 
                        level=logging.DEBUG, format='%(asctime)s: %(message)s')

    # Now that logging is set up decouple from parent environnement
    redirect_stream(sys.stdin,  None)
    redirect_stream(sys.stdout, None)
    redirect_stream(sys.stderr, None)    

    # General Control Functions 
    server.register_function(keithley.status,       "status")
    server.register_function(keithley.open,         "open")
    server.register_function(keithley.close,        "close")
    server.register_function(keithley.reset,        "reset")
    server.register_function(keithley.clear,        "clear")
    server.register_function(keithley.get_serial,   "get_serial")
    server.register_function(keithley.get_serial,   "checkConnection")

    # Keithley generic command
    server.register_function(keithley.send,         "send")
    # server.register_function(keithley.check_error_status,"check_error_status")
    server.register_function(keithley.get_error_status,  "get_error_status")

    # misc 
    server.register_function(keithley.scroll_text,  "scroll_text")
    server.register_function(server_quit,           "quit")

    # for remote introspection (tab completion with ipython)
    server.register_function(keithley._listMethods, "__dir__")
    server.register_function(keithley._listMethods, "system.listMethods")
    server.register_function(keithley._listMethods,  "trait_names")
    server.register_function(keithley._listMethods,  "_getAttributeNames")
    # TODO: implement: system.methodSignature
    server.register_function(keithley._methodHelp,  "system.methodHelp")

    logging.info("Server going up.")
    server.serve_forever()

# ------------------------------------------------------------------

# ==================================================================

if __name__ == '__main__':

    # ------------- log file ----------------------

    now = datetime.datetime.now()
    # logname = ( "keithley-server-%s-%d-%s.log" % 
    #             ( SERVER_DEVICE, SERVER_PORT,
    #               now.isoformat().split('T')[0] ) )
    logname = ( "keithley-server-%s.log" % 
                now.isoformat().split('T')[0] )
                
    # ------------- parsing command line ----------

    import optparse
    parser = optparse.OptionParser(usage="""
%prog [-d] 

Start the Keithley Electrometer remote control server. 
""")
    parser.add_option('-d', '--daemon', default=False, action='store_true',
                      help='Run as a background daemon')
    parser.add_option('-H', '--hostname', default=SERVER_HOSTNAME, action='store',
                      help='Listen adress')
    parser.add_option('-p', '--port', default=SERVER_PORT, action='store', type='int',
                      help='Listen on port')
    parser.add_option('-D', '--device', default=SERVER_DEVICE, action='store',
                      help='Serial port device')
    parser.add_option('-l', '--log-file', default=logname, action='store',
                      help='Specify a file for daemon logs.')

    (options, args) = parser.parse_args()

    # ------------- XML-RPC Server ----------------

    SERVER_HOSTNAME = options.hostname
    SERVER_PORT = int(options.port)
    SERVER_DEVICE = options.device
    
    # ------------- Initialize Instrument ---------

    keithley = KeithleyRemote(device = SERVER_DEVICE)

    # server = SimpleXMLRPCServer(("dicehead", 8001))
    server = KeithleyServer((SERVER_HOSTNAME, SERVER_PORT))
    server.register_introspection_functions()

    # ---------------------------------------------

    print "Keithley: talking to device %s: listening on port %s:%d. Waiting for commands." % (SERVER_DEVICE, SERVER_HOSTNAME, SERVER_PORT)
    
    if options.daemon:
        daemonize(options, args)
    else:
        main(options, args)


# ==================================================================
#! /usr/bin/env python

import sys
import os, os.path
import time

import struct
from array import array

import dice.control.backend as dcb

# ----------------------------------------------------------------------------

def remaining():
    return dcb.read_at(0x17, 0x19)

# ----------------------------------------------------------------------------

# syntax: readclap <wordcount> <frequency> <channels> <repeat> <delay> <filename> [<blocksize>]

if len(sys.argv) < 7:
    print >>sys.stderr, "Usage: ",
    print >>sys.stderr, "readclap <wordcount> <frequency> <channels> <repeat> <delay> <filename> [<blocksize>]"
    sys.exit(1)

wordcount = int(sys.argv[1])

if wordcount > 8387583:
    print >>sys.stderr, "wordcount too large. Should be <= 8387583 (FIFO size)."
    sys.exit(1)

frequency = float(sys.argv[2])

if (frequency < 1.) or (frequency > 500.):
    print >>sys.stderr, "frequency should be between 1kHz and 500kHz (specified in kHz)."
    sys.exit(1)

period_s = 1./(1000.*frequency)
clock_period = 20.0e-9  # 20 ns
period = int(period_s / clock_period)

channels  = (sys.argv[3]).lower()
repeat    = int(sys.argv[4])
delay     = float(sys.argv[5])
filename  = sys.argv[6]

blocksize = 32768
if len(sys.argv) >= 8:
    blocksize = int(float(sys.argv[7]))
    if blocksize > 32768:
        print >>sys.stderr, "max blocksize is 32768 (reset to this value)"
        blocksize = 32768

end_of_loop = False

if delay < 0.:
    print >>sys.stderr, \
        "delay between acquisitions periods should be > 0 (specified in s)."
    sys.exit(1)


channel_mask = 0x00
if ("b0" in channels) or ("g1" in channels) or ("gain1" in channels):
    channel_mask |= 0x01
if ("b1" in channels) or ("g32" in channels) or ("gain32" in channels):
    channel_mask |= 0x02
if ("b2" in channels) or ("tclap0" in channels) or ("tempclap0" in channels):
    channel_mask |= 0x04
if ("b3" in channels) or ("tclap1" in channels) or ("tempclap1" in channels):
    channel_mask |= 0x08
if ("b4" in channels) or ("tbe" in channels) or ("tempbe" in channels):
    channel_mask |= 0x10
if ("b5" in channels) or ("lemo" in channels):
    channel_mask |= 0x20
if ("b6" in channels) or ("biasout" in channels) or ("bias" in channels):
    channel_mask |= 0x40
if ("b7" in channels) or ("groundfe" in channels) or ("gndfe" in channels):
    channel_mask |= 0x80

if channel_mask == 0x00:
    print >> sys.stderr, "Warning: no channel specified: defaults to channel 1."
    channel_mask = 0x01

if ("LOOP" in channels) or ("loop" in channels):
    end_of_loop = True


# Open the USB port
dcb.open(debug = False)

# Reset HARD
dcb.write(0x1b, bytearray([1]))

# Choose the channels to be read
# OLD WAY dcb.write(0x02, bytearray([channel_mask]))
# new way:
print("Channels mask: 0x%02X" % channel_mask)
dcb.write(0x1c, bytearray([channel_mask]))

# end-of-loop mark for interleaved data
print("End-of-loop: ", end_of_loop)
eol_byte = 0x00
if end_of_loop:
    eol_byte = 0x01
dcb.write(0x1d, bytearray([eol_byte]))

# OLD WAY # Choose the frequency
# OLD WAY # dcb.write(0x04, bytearray([frequency]))
# Now it is a period (expressed in clock cycles)
# sampling_bytes = dcub.uint_to_n_bytes(period, 2)
# dcb.write(0x04, bytearray([sampling_bytes[1]]))
# dcb.write(0x05, bytearray([sampling_bytes[0]]))
dcb.write_at(0x04, 0x05, period)

# Choose the mode and number of words to be read
dcb.write(0x06, bytearray([0]))

print ( "Each data acquisition block will take %.2f s" % 
        (wordcount / (1e3 * frequency) ) )

# bytes = int_to_n_bytes(wordcount, 3)
# dcb.write(0x16, bytearray([bytes[0]]))
# dcb.write(0x15, bytearray([bytes[1]]))
# dcb.write(0x14, bytearray([bytes[2]]))
dcb.write_at(0x14, 0x16, wordcount)

# Open the output file

f = open(filename, 'w')

print >>f, "## CLAP data acquisition"
print >>f, "#channels = ", channels
print >>f, "#wordcount = ", wordcount
print >>f, "#frequency = ", frequency
print >>f, "#period (x 20 ns) = ", period
print >>f, "#repeat = ", repeat

# And now repeat the readout

for i in xrange(repeat):

    # Optional delay between two acquisitions

    if (delay > 0) and (i >= 1): 
        print "Now waiting for %f seconds..."  % delay        
        time.sleep(delay)
        print "done."

    print "----------------------------------------------------"
    print "Block %d / %d starting..." % (i, repeat)

    # Reset "soft" (TEST)

    dcb.write(0x1a, bytearray([1]))

    # Get a timestamp time.time()

    host_timestamp = time.time()

    # Start writing into the FIFO (from the ADC)
    dcb.write(0x03, bytearray([0x02]))

    time.sleep(1)

    # Now, we have to wait until (0x0A & 0x01) is off

    print "Starting to write ADC output to FIFO",

    t_start = time.time()
    while (dcb.read(0x0A)[0] & 0x01):
        sys.stdout.write('.')
        sys.stdout.flush()
        time.sleep(1)
    t_stop = time.time()

    print "\nEnd of FIFO writing."
    print "Writing FIFO took %f s" % (t_stop - t_start)

    # Now readout from the FIFO

    print "Now we have to read %d 2-byte words" % remaining()

    data = bytearray()
    ### data = bytearray(2 * wordcount)
    ### data_pos = 0

    t_start = time.time()

    print "Starting FIFO readout..."

    while (dcb.read(0x0A)[0] & 0x04):
        # How many remain to be read ?
        amount = remaining()
        print "remains: %d 2-byte words" % amount
        if amount <= 0:
            break
    
        if amount >= blocksize:
            size = 2 * blocksize
        else:
            size = 2 * amount

        rd = dcb.read(0x08, size)
        chunk_length = len(rd)
        print "read %d bytes" % chunk_length
        data.extend(rd)
        ### data[data_pos:data_pos+chunk_length] = rd  # Test
        ### data_pos+=chunk_length                     
        print "concatenated with already read data."
        # latency (is it useful ???)
        time.sleep(0.05)
        # print "how much remain to be read ?"
        amount = remaining()
        print "remains after reading: %d" % amount


    t_stop = time.time()

    print "End of FIFO readout."
    print "%d bytes received in %f s." % (len(data), t_stop - t_start)

    # # Converting into unsigned words:
    # nn = [ 256*data[2*i+1]+data[2*i] for i in xrange(len(data)/2) ]

    # Converting into signed words:
    # nn = [ 256*data[2*i+1]+data[2*i] for i in xrange(len(data)/2) ]
    fmt = "<%dh" % (len(data) / 2)
    # nn = struct.unpack(fmt, array('B', data))
    converted_data = struct.unpack(fmt, str(data))

    # Get Board timestamp

    # board_timestamp = n_bytes_to_int([ dcb.read(0x22)[0],
    #                                    dcb.read(0x21)[0],
    #                                    dcb.read(0x20)[0],
    #                                    dcb.read(0x1F)[0],
    #                                    dcb.read(0x1E)[0] ])
    board_timestamp = dcb.read_at(0x1E,0x22)
    
    # Write data to file

    print >>f, "#" + 70 * "-"
    print >>f, "#block = ", i
    print >>f, "#host timestamp  (BIOS clock, time.time())            = %.14f" \
        % host_timestamp
    print >>f, "#board timestamp (board internal clock 20ns sampling) = %d" \
        % board_timestamp

    for idx in xrange(len(converted_data)):
        print >>f, "%g" % converted_data[idx]


    print "Block %d / %d done." % (i, repeat)


# pylab.scatter(xrange(len(nn[-10000:])),nn[-10000:], marker='+', color='b')
# pylab.show()

# print "Press a key to continue."
# raw_input()

print "----------------------------------------------------"

print >>f, "#" + 70 * "-"

f.close()

dcb.close()

# ----------------------------------------------------------------------------
