#! /usr/bin/env python

# --------------------------------------------------------------------------

import os
import os.path as op
import sys
import time
import datetime
from optparse import OptionParser
import logging

# --------------------------------------------------------------------------
SERVER_HOSTNAME = os.getenv("DICE_SERVER_HOSTNAME", "localhost")
SERVER_PORT = int(os.getenv("DICE_SERVER_PORT", 8001))

# --------------------------------------------------------------------------
import xmlrpclib
proxy = xmlrpclib.ServerProxy("http://%s:%d/" % (SERVER_HOSTNAME, SERVER_PORT))

def status(opts):
    logging.info("dice: status() ...")
    ret = proxy.status()
    print ret['backend'], ret['alt_motor'], ret['az_motor']
    return True

def init(opts):
    # logging.info("dice: init() ...")
    logging.info("dice: init() ...") 
    ret = proxy.init()
    return True

def home(opts):
    logging.info("dice: home() [this takes about 20 s] ...")
    ret = proxy.home()
    return True

def move_absolute(opts):
    logging.info("dice: move_absolute(alt=%s,az=%s,wait=%r) ..." % (opts.alt, opts.az, opts.wait))
    ret = proxy.move_absolute(opts.alt, opts.az, opts.wait)
    return ret

def move_relative(opts):
    logging.info("dice: move_relative(dalt=%s,daz=%s,wait=%r) ..." % (opts.dalt, opts.daz, opts.wait))
    ret = proxy.move_relative(opts.dalt, opts.daz, opts.wait)
    return ret

def at_target(opts):
    logging.info("dice: at_target() ...")
    ret = proxy.at_target()
    return ret

def position(opts):
    logging.info("dice: position() ...")
    ret = proxy.position()
    print ret[0], ret[1]
    return ret

def park(opts):
    logging.info("dice: park() [this takes about 20s]...")    
    ret = proxy.park()
    return ret

def motor_init(opts):
    logging.info("dice: motor_init() ...")    
    ret = proxy.motor_init()
    return ret

def motor_status(opts):
    logging.info("dice: motor_status() ...")    
    ret = proxy.motor_status()
    print ret[0], ret[1]
    return ret

def led_on(opts):
    logging.info("dice: led_on(%d) ..." % opts.led)
    ret = proxy.led_on(opts.led)
    return ret

def led_off(opts):
    logging.info("dice: led_off() ...")
    ret = proxy.led_off()
    return ret

def planet_on(opts):
    logging.info("dice: planet_on() ...")
    ret = proxy.planet_on()
    return ret

def planet_off(opts):
    logging.info("dice: planet_off() ...")
    ret = proxy.planet_off()
    return ret

FITS_comment = {
    "ILEDT" : "LED current [timestamp]",
    "ILEDC" : "LED current [channel]",
    "ILEDN" : "LED current [number of samples]",
    "ILEDM" : "LED current [mean]",
    "ILEDV" : "LED current [variance]",
    "IPHDT" : "Photodiode current [timestamp]",
    "IPHDC" : "Photodiode current [channel]",
    "IPHDN" : "Photodiode current [number of samples]",
    "IPHDM" : "Photodiode current [mean]",
    "IPHDV" : "Photodiode current [variance]",
    "T24T" :  "LED temperature [timestamp]",
    "T24C" :  "LED temperature [channel]",
    "T24N" :  "LED temperature [number of samples]",
    "T24M" :  "LED temperature [mean]",
    "T24V" :  "LED temperature [variance]",
    "TBET" :  "Backend temperature [timestamp]",
    "TBEC" :  "Backend temperature [channel]",
    "TBEN" :  "Backend temperature [number of samples]",
    "TBEM" :  "Backend temperature [mean]",
    "TBEV" :  "Backend temperature [variance]",
    "VREFT" : "Vref [timestamp]",
    "VREFC" : "Vref [channel]",
    "VREFN" : "Vref [number of samples]",
    "VREFM" : "Vref [mean]",
    "VREFV" : "Vref [variance]",
}

def sample_and_dump(opts):
    logging.info("dice: sample_and_dump(%d) ... " % opts.led)
    ret = proxy.sample_and_dump(opts.led)
    for k,v in ret:
        print "%-8s=%+20s / %s" % (k+opts.suffix,v,FITS_comment[k])
    return True

def stop(opts):
    ret = proxy.stop()
    return True

def quit(opts):
    ret = proxy.quit()
    return True

def fail(opts):
    ret = proxy.fail()
    return True

# --------------------------------------------------------------------------
commands = {
    "status": status,
    "init" : init,
    "home" : home,
    "move_absolute" : move_absolute,
    "ma" : move_absolute,
    "move_relative" : move_relative,
    "mr" : move_relative,
    "at_target": at_target, 
    "position" : position, 
    "park" : park, 
    "motor_init" : motor_init, 
    "motor_status" : motor_status, 
    "led_on" : led_on,
    "led_off" : led_off, 
    "planet_on" : planet_on, 
    "planet_off" : planet_off, 
    "sample_and_dump" : sample_and_dump, 
    "stop": stop,
    "fail": fail,
    "quit": quit
    }

# --------------------------------------------------------------------------
if __name__ == "__main__":
    usage = "usage: %s <command> [OPTIONS]" % sys.argv[0]
    usage += """

COMMANDS: 
  init                    initialize the LED head 

  home                    check the motor mechanical stops and 
                          redetermine the zeros of the motor. 
                          NOTE: take about 20s to complete

  move_absolute | ma   [--alt= --az=]    
                          move the head to the requested position 

  move_relative | mr   [--dalt= --daz=]  
                          move the head by dalt and daz

  at_target               return 0 if the position specified to the motors has been reached
                                 1 if still moving (or blocked)

  position                return the current position of the motors 

  park                    park the head to a safe position 

  led_on   [--led=]       switch on the LED specified with the --led option 

  led_off                 switch off all LEDs

  planet_on               switch on the planet beam

  planet_off              switch off the planet beam

  sample_and_dump [--led] [--suffix]
                          read the internal parameters of the LED head
                          and dump them on the console as a series of 
                          FITS header lines. 
                          if the --suffix option is used, its argument 
                          is appended to the header keys. 

  fail                    raise an exception
"""    

    parser = OptionParser(usage)
    parser.add_option('-l', '--led', dest='led', 
                      help='specify a LED channel', 
                      type=int, default=1)
    parser.add_option('-c', '--current', dest='current', 
                      help='specify a LED current')
    parser.add_option('-f', '--force', dest='force', 
                      help='bypass current limits (assume you know what you are doing)')
    parser.add_option('--alt', dest='alt', 
                      help='specify an absolute position (in coder steps) on the altitude axis',
                      type=float, default=0.)
    parser.add_option('--az', dest='az', 
                      help='specify an absolute position (in coder steps) on the azimuth axis', 
                      type=float, default=0.)
    parser.add_option('--dalt', dest='dalt', 
                      help='specify a relative motion (in coder steps) on the altitude axis', 
                      type=float, default=0.)
    parser.add_option('--daz', dest='daz', 
                      help='specify a relative motion position (in coder steps) on the azimuth axis', 
                      type=float, default=0.)
    parser.add_option('--wait', dest='wait', 
                      help='whether we should wait for the command completion', 
                      action="store_true", 
                      default=False)
    parser.add_option('--suffix', dest='suffix', 
                      help='specify a suffix for the dice_sample_and_dump keys', 
                      default="")
    parser.add_option('-v', '--verbose', dest='verbose', 
                      help='be more verbose', 
                      action="store_true",
                      default=False)
    
    opts, args = parser.parse_args()
    if len(args) != 1:
        parser.error("no command specified")
        sys.exit(1)
        
    # logger 
    now = datetime.datetime.now()
    logname = "dice-%s.log" % now.isoformat().split('T')[0]
    logging.basicConfig(filename=logname, 
                        level=logging.DEBUG, format='%(asctime)s: %(message)s')
    if opts.verbose: 
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(logging.getLogger().handlers[0].formatter)
        logging.getLogger().addHandler(console_handler)
        
    # check that the command exists 
    cmd = args[0]
    if cmd not in commands:
        parser.error("no such command")
        sys.exit(1)
        
    # run the command 
    ret = ''
    try:
        ret = commands[cmd](opts)
    except:
        print >>sys.stderr, sys.exc_info()
        sys.exit(1)
        
    sys.exit(0)

